<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Scratch</title>
    <style>
      :root {
        font-size: 0.1vw;
      }

      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        background-color: #888;
      }

      li {
        list-style: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .box {
        width: 250rem;
        height: 125rem;
        background-color: #eedc5b;
        border-radius: 8rem;
        cursor: move;
        transition: opacity 300ms ease-in-out;
        font-size: 64rem;
        line-height: 125rem;
        text-align: center;
        user-select: none;
      }

      .box__what-if {
        border: dashed 4px #5d6eee;
        opacity: 0.5;
      }

      .box__lifted {
        transform: scale(1.05);
        box-shadow: 3px 3px 6px #222;
        z-index: 100;
        transition: none;
      }

      .box__collided {
        background-color: crimson;
      }

      .box-wrap {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: 20rem;
        /* adding 14rem is magic that makes each row has 3 boxes */
        width: calc(250rem * 3 + 20rem * 2 + 20rem * 2 + 4rem * 2 + 14rem);
        padding: 20rem;
        border: solid 4px #5d6eee;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>
    <ul class="box-wrap">
      <li class="box">1</li>
      <li class="box">2</li>
      <li class="box">3</li>
      <li class="box">4</li>
      <li class="box">5</li>
      <li class="box">6</li>
      <li class="box">7</li>
      <li class="box">8</li>
      <li class="box">9</li>
      <li class="box">10</li>
      <li class="box">11</li>
      <li class="box">12</li>
    </ul>
    <script>
      const posBeforeDragStart = new Map();

      function boxOnDragStart(box) {
        return (e) => {
          box.classList.add("box__what-if");
          e.dataTransfer.beingDragged = box;
          aBox.forEach((box) => {
            const pos = box.getBoundingClientRect();
            posBeforeDragStart.set(box, [
              pos.x + pos.width / 2,
              pos.y + pos.height / 2,
            ]);
          });
        };
      }

      function boxOnDragEnd(box) {
        return () => {
          box.classList.remove("box__what-if");
        };
      }

      function distance(x1, y1, x2, y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
      }

      function findClosestElementFromPoint(x, y, elements) {
        let closest = elements[0] ?? null;
        let minCenterDistSqr = Infinity;
        const c1X = x;
        const c1Y = y;
        for (const element of elements) {
          const r = element.getBoundingClientRect();
          const c2X = r.x + r.width / 2;
          const c2Y = r.y + r.height / 2;
          const centerDistanceSqr =
            (c1X - c2X) * (c1X - c2X) + (c1Y - c2Y) * (c1Y - c2Y);
          if (centerDistanceSqr < minCenterDistSqr) {
            minCenterDistSqr = centerDistanceSqr;
            closest = element;
          }
        }
        return closest;
      }

      function Throttler(minIntervalMilliSec) {
        this.ok = true;
        this.timer = null;
        this.minIntervalMilliSec = minIntervalMilliSec;
        this.canDo = function () {
          const oldOk = this.ok;
          this.ok = false;
          if (this.timer === null) {
            setTimeout(() => {
              this.ok = true;
              this.timer = null;
            }, this.minIntervalMilliSec);
          }
          return oldOk;
        };
      }

      const aBox = Array.from(document.querySelectorAll(".box"));
      const oBoxWrap = document.querySelector(".box-wrap");
      const relocationThrottle = new Throttler(500);
      aBox.forEach((box) => {
        box.setAttribute("draggable", "true");
        box.addEventListener("dragstart", boxOnDragStart(box));
        box.addEventListener("dragend", boxOnDragEnd(box));
      });
      oBoxWrap.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        const beingDragged = oBoxWrap.querySelector(".box.box__what-if");
        const boxToTheRightAndBelow = aBox
          .filter((other) => other !== beingDragged)
          .filter((other) => {
            const r = other.getBoundingClientRect();
            const cX = r.x + r.width / 2;
            const cY = r.y + r.height / 2;
            return cX >= e.clientX && cY >= e.clientY;
          });
        console.log(
          "possible insertAfterThis candidates",
          boxToTheRightAndBelow.map((b) => b.textContent),
        );
        const insertBeforeThis = Array.from(
          posBeforeDragStart.entries(),
        ).reduce(
          (ans, [other, pos]) => {
            const d = distance(e.clientX, e.clientY, ...pos);
            if (ans.distance > d) {
              ans.insert = other;
              ans.distance = d;
            }
            return ans;
          },
          {
            insert: null,
            distance: Infinity,
          },
        ).insert;
        if (insertBeforeThis !== null) {
          console.log("insert after this", insertBeforeThis.textContent);
          oBoxWrap.insertBefore(beingDragged, insertBeforeThis);
        }
      });
    </script>
  </body>
</html>
