<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Scratch</title>
    <style>
      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        background-color: #888;
      }

      li {
        list-style: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .box {
        width: 200px;
        height: 100px;
        background-color: limegreen;
        border-radius: 8px;
        cursor: move;
        transition: 300ms ease-in-out;
        font-size: 64px;
        line-height: 100px;
        text-align: center;
        user-select: none;
      }

      .box__lifted {
        transform: scale(1.05);
        box-shadow: 3px 3px 6px #222;
        z-index: 100;
        transition: none;
      }

      .box__collided {
        background-color: crimson;
      }

      .box-wrap {
        position: relative;
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        width: calc(200px * 3 + 20px * 2 + 20px * 2 + 4px * 2);
        padding: 20px;
        border: solid 4px lightgreen;
        border-radius: 8px;
      }
    </style>
  </head>

  <body>
    <ul class="box-wrap">
      <li class="box">1</li>
      <li class="box">2</li>
      <li class="box">3</li>
      <li class="box">4</li>
      <li class="box">5</li>
      <li class="box">6</li>
      <li class="box">7</li>
      <li class="box">8</li>
      <li class="box">9</li>
      <li class="box">10</li>
      <li class="box">11</li>
      <li class="box">12</li>
    </ul>
    <script>
      function boxOnDragStart(box) {
        return () => {
          aBox.forEach((box) => box.classList.remove("box__collided"));
          box.classList.toggle("box__lifted");
        };
      }

      function boxOnDragEnd(box) {
        return () => {
          boxOnDragStart(box)();
          reflowBoxes(aBox);
        };
      }

      function findCollidedElements(me, others) {
        return others.filter((other) => {
          const t1 = me.offsetTop;
          const t2 = other.offsetTop;
          const l1 = me.offsetLeft;
          const l2 = other.offsetLeft;
          const r1 = l1 + me.offsetWidth;
          const r2 = l2 + other.offsetWidth;
          const b1 = t1 + me.offsetHeight;
          const b2 = t2 + other.offsetHeight;
          return !(t1 > b2 || r1 < l2 || b1 < t2 || l1 > r2);
        });
      }

      function findClosestElement(me, others) {
        let collidedBox = others[0];
        let minCenterDistSqr = Number.MAX_SAFE_INTEGER;
        for (const other of others) {
          const t1 = me.offsetTop;
          const t2 = other.offsetTop;
          const l1 = me.offsetLeft;
          const l2 = other.offsetLeft;
          const r1 = l1 + me.offsetWidth;
          const r2 = l2 + other.offsetWidth;
          const b1 = t1 + me.offsetHeight;
          const b2 = t2 + other.offsetHeight;
          const c1X = (l1 + r1) / 2;
          const c1Y = (t1 + b1) / 2;
          const c2X = (l2 + r2) / 2;
          const c2Y = (t2 + b2) / 2;
          const centerDistanceSqr =
            (c1X - c2X) * (c1X - c2X) + (c1Y - c2Y) * (c1Y - c2Y);
          if (centerDistanceSqr < minCenterDistSqr) {
            minCenterDistSqr = centerDistanceSqr;
            collidedBox = other;
          }
        }
        return collidedBox;
      }

      function findCollidedBox(me, others) {
        return findClosestElement(me, findCollidedElements(me, others));
      }

      function boxOnDragMove(box) {
        function markCollidedBox(bb) {
          aBox.forEach((other) => other.classList.remove("box__collided"));
          if (bb === null) {
            return;
          }
          bb.classList.add("box__collided");
        }

        return () => {
          const others = aBox.filter((b) => b !== box);
          const dragTo = findCollidedBox(box, others);
          markCollidedBox(dragTo);
        };
      }

      function Throttler(minIntervalMilliSec) {
        this.ok = true;
        this.timer = null;
        this.minIntervalMilliSec = minIntervalMilliSec;
        this.canDo = function () {
          const oldOk = this.ok;
          this.ok = false;
          if (this.timer === null) {
            setTimeout(() => {
              this.ok = true;
              this.timer = null;
            }, this.minIntervalMilliSec);
          }
          return oldOk;
        };
      }

      const aBox = Array.from(document.querySelectorAll(".box"));
      const oBoxWrap = document.querySelector(".box-wrap");
      const relocationThrottle = new Throttler(500);
    </script>
  </body>
</html>
